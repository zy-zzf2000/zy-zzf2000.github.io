<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zy-zzf2000.github.io/</id>
    <title>小张的网站</title>
    <updated>2019-12-12T15:41:17.929Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zy-zzf2000.github.io/"/>
    <link rel="self" href="https://zy-zzf2000.github.io//atom.xml"/>
    <subtitle>莫道君行早，更有早行人</subtitle>
    <logo>https://zy-zzf2000.github.io//images/avatar.png</logo>
    <icon>https://zy-zzf2000.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, 小张的网站</rights>
    <entry>
        <title type="html"><![CDATA[2019]]></title>
        <id>https://zy-zzf2000.github.io//post/2019</id>
        <link href="https://zy-zzf2000.github.io//post/2019">
        </link>
        <updated>2019-11-07T11:54:58.000Z</updated>
        <content type="html"><![CDATA[<h1 id="things-that-i-have-done">Things that I have done...</h1>
<hr>
<h1 id="things-that-i-shouldt-have-done">Things that I should't have done...</h1>
<hr>
<h1 id="things-that-i-should-have-done">Things that I should have done...</h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Sonnet 18]]></title>
        <id>https://zy-zzf2000.github.io//post/sonnet-18</id>
        <link href="https://zy-zzf2000.github.io//post/sonnet-18">
        </link>
        <updated>2019-11-04T12:24:59.000Z</updated>
        <content type="html"><![CDATA[<p>to be continue...</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[赤壁赋]]></title>
        <id>https://zy-zzf2000.github.io//post/chibifu</id>
        <link href="https://zy-zzf2000.github.io//post/chibifu">
        </link>
        <updated>2019-11-02T06:04:44.000Z</updated>
        <content type="html"><![CDATA[<p>壬戌之秋，七月既望，苏子与客泛舟游于赤壁之下。清风徐来，水波不兴。举酒属客，诵明月之诗，歌窈窕之章。少焉，月出于东山之上，徘徊于斗牛之间。白露横江，水光接天。纵一苇之所如，凌万顷之茫然。浩浩乎如冯虚御风，而不知其所止；飘飘乎如遗世独立，羽化而登仙。</p>
<p>于是饮酒乐甚，扣舷而歌之。歌曰：“桂棹兮兰桨，击空明兮溯流光。渺渺兮予怀，望美人兮天一方。”客有吹洞箫者，倚歌而和之。其声呜呜然，如怨如慕，如泣如诉，余音袅袅，不绝如缕。舞幽壑之潜蛟，泣孤舟之嫠妇。</p>
<p>苏子愀然，正襟危坐而问客曰：“何为其然也？”客曰：“月明星稀，乌鹊南飞，此非曹孟德之诗乎？西望夏口，东望武昌，山川相缪，郁乎苍苍，此非孟德之困于周郎者乎？方其破荆州，下江陵，顺流而东也，舳舻千里，旌旗蔽空，酾酒临江，横槊赋诗，固一世之雄也，而今安在哉？况吾与子渔樵于江渚之上，侣鱼虾而友麋鹿，驾一叶之扁舟，举匏樽以相属。<strong>寄蜉蝣于天地，渺沧海之一粟。哀吾生之须臾，羡长江之无穷。挟飞仙以遨游，抱明月而长终。知不可乎骤得，托遗响于悲风。”</strong></p>
<p>苏子曰：“客亦知夫水与月乎？逝者如斯，而未尝往也；盈虚者如彼，而卒莫消长也。盖将自其变者而观之，则天地曾不能以一瞬；自其不变者而观之，则物与我皆无尽也，而又何羡乎!且夫天地之间，物各有主,苟非吾之所有，虽一毫而莫取。惟江上之清风，与山间之明月，耳得之而为声，目遇之而成色，取之无禁，用之不竭，是造物者之无尽藏也，而吾与子之所共适。”</p>
<p>客喜而笑，洗盏更酌。肴核既尽，杯盘狼籍。相与枕藉乎舟中，不知东方之既白。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[散列]]></title>
        <id>https://zy-zzf2000.github.io//post/san-lie</id>
        <link href="https://zy-zzf2000.github.io//post/san-lie">
        </link>
        <updated>2019-10-31T04:54:14.000Z</updated>
        <content type="html"><![CDATA[<p>待续...</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[我是想站着，还把钱挣了]]></title>
        <id>https://zy-zzf2000.github.io//post/让子弹飞</id>
        <link href="https://zy-zzf2000.github.io//post/让子弹飞">
        </link>
        <updated>2019-10-27T02:14:13.000Z</updated>
        <content type="html"><![CDATA[<p>tmd，这大叔也太帅了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[KMP算法-从PMT角度理解]]></title>
        <id>https://zy-zzf2000.github.io//post/KMP</id>
        <link href="https://zy-zzf2000.github.io//post/KMP">
        </link>
        <updated>2019-10-19T14:43:45.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>在最近的课堂上，老师讲了KMP算法，但总感觉老师的推理过程有些不连贯，所以决定自己梳理一遍KMP算法</p>
</blockquote>
<hr>
<h1 id="1-next数组是什么">1、next数组是什么</h1>
<p>KMP算法的核心就是next数组。在KMP算法中，模式字符串的每一位均对应一个next值，即当主字符串与模式字符串在这一位发生失配时，模式字符串的指针不用回溯到0，只需回溯到next值即可。理解next数组是理解KMP算法的关键。</p>
<hr>
<h1 id="2-next数组的由来">2、next数组的由来</h1>
<p>在课本中，KMP算法是由BF算法改进而来的。但我个人认为这样并不好理解（其实是我当初看的时候没看懂，结果上课又没听懂）。在网上查阅之后，发现从PMT数组的角度似乎能更好的理解next数组。</p>
<p>PMT数组，即部分匹配表(Partial Match Table)，与next数组一样，对于模式字符串的每一位，它都有一个对应的值，如下图：<br>
<img src="https://zy-zzf2000.github.io//post-images/1572084892998.jpg" alt=""><br>
通俗的说，next数组里的值就是模式字符串当前位置子串中，前缀与后缀最大重复元素的长度。这样说也许还是难以理解，让我们用上图来举几个例子。<br>
可以看到，PMT【1】=0，这是因为对于字串“ab”，它的前缀只有‘a’，后缀只有‘b’，因此没有重复部分；PMT【2】=1，这是因为对于字串“aba”，它的前缀有“a”、“ab”，后缀有“ba”、“a”，其中最大重复元素位“a”，因此最大重复元素的长度=PMT值=1。以此类推...</p>
<p>PMT数组有什么用呢？PMT数组可以用来帮我们省去一些不必要的比较。如下图所示：<br>
<img src="https://zy-zzf2000.github.io//post-images/1572085486261.jpg" alt=""><br>
在图（a）中，主串与模式字符串即将发生失配。由PMT数组我们知道，对于模式字符串的子串“ababab”（即指针j前的字串），它的PMT值为4（PMT【j-1】），也就是说，它的前缀与后缀有4位是重复的。而主串与模式字符串失配前的每一位都是一样的，于是我们可以得出，主串的i指针之前的4位，相当于“ababab”的后缀，而模式字符串的前四位，相当于“ababab”的前缀，他们也是相等的。既然模式字符串的前四位已经相等了，那么我们在下一次进行比较的时候，就没有必要再对它们进行比较了，如图（b）所示，我们保持i指针不变，直接将j指针移动到第五位，直接从模式字符串的第五位开始比较。</p>
<p>从上面我们可以看出，如果再比较时，考虑PMT数组，那么每当发生失配时，我们的j指针就不必回溯到0，只需要回溯到PMT【j-1】所指示的位置。为了编程方便，我们将PMT数组整体后移一位，这样就得到了next数组。原来next数组只是一个提供便利的“衍生物”。如下图所示：<br>
<img src="https://zy-zzf2000.github.io//post-images/1572086367096.jpg" alt=""><br>
在上图中可以发现next【0】被设置为了-1，这是为了便于编程，使我们知道主串在第一位便发生了失配，这时候，i指针就要向后移动一位。</p>
<hr>
<h1 id="3-代码">3、代码</h1>
<p>既然明白了next数组的由来，我个人认为实现它也就不困难了。</p>
<pre><code class="language-c++">int KMP(char* t,char* p){
	int i=0,j=0;;
	while(i&lt;strlen(t)&amp;&amp;j&lt;strlen(p)){
		if(j==-1){		//如果j=-1，说明主串第一个字符就与模式字符串失配 
			i++;		//主串指针下移一位 
			j=0;		//模式字符串指针回溯到0 
		}
		else if(t[i]==p[j]){	//如果当前位相等，则继续比较下一位 
			i++;
			j++;
		}
		else{			//发生失配 
			j=next[j];	//模式字符串回溯到next[j]处 
		}
	}
} 
</code></pre>
<p>当然，如何实现next数组甚至比KMP算法更关键<br>
这里我直接引用知乎上的说法：</p>
<blockquote>
<p>其实，求next数组的过程完全可以看成字符串匹配的过程，即以模式字符串为主字符串，以模式字符串的前缀为目标字符串，一旦字符串匹配成功，那么当前的next值就是匹配成功的字符串的长度。<br>
具体来说，就是从模式字符串的第一位(注意，不包括第0位)开始对自身进行匹配运算。 在任一位置，能匹配的最长长度就是当前位置的next值。</p>
</blockquote>
<p>我只补充一点，那就是匹配成功之后，模式字符串的指针j+1就是所谓最长长度，也就是next的值。</p>
<p>下面是几张图片：<br>
<img src="https://zy-zzf2000.github.io//post-images/1572100503477.jpg" alt=""><br>
<img src="https://zy-zzf2000.github.io//post-images/1572100507615.jpg" alt=""><br>
<img src="https://zy-zzf2000.github.io//post-images/1572100511040.jpg" alt=""><br>
<img src="https://zy-zzf2000.github.io//post-images/1572100514912.jpg" alt=""><br>
<img src="https://zy-zzf2000.github.io//post-images/1572100518437.jpg" alt=""><br>
实际上，无论什么时候，都有next【0】=-1，next【1】=0.这是因为，next数组是由PMT数组右移一位得来，我们约定next【0】=-1，便于编程；而next【1】的值，实际上是主串第一个字符最大重复元素的长度，显然为0.<br>
值得注意的是，计算next数组时，要从第一位开始，即第0位不参与，由于next数组是由PMT数组右移一位得来，那么，第一位所得到的值实际上是next【2】的值。<br>
这两段也就解释了为什么上图是从next【2】开始计算的。</p>
<pre><code class="language-c++">void getNext(char *p,int *next){
	next[0]=-1;  //next[0]被约定为-1
	next[1]=0;   //next[1]一定是0
	int i=1,j=0;
	while(i &lt; strlen(p)-1) {
		if (j == -1 || p[i] == p[j]){
			++i;
			++j;
			next[i] = j;
		}
		else{
			j = next[j];
		}
	}
} 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[逆波兰算法实现简单优先计算器]]></title>
        <id>https://zy-zzf2000.github.io//post/逆波兰</id>
        <link href="https://zy-zzf2000.github.io//post/逆波兰">
        </link>
        <updated>2019-10-17T14:43:18.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>1、只实现了+、-、*、/、（、）的优先级运算<br>
2、实现了多位数的运算</p>
</blockquote>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;stack&gt;
#include &lt;vector&gt;
#include &lt;stdlib.h&gt;
#include &lt;sstream&gt;
using namespace std;



const static char priority[7][7] =  //丑陋的优先级比较方式
    {
        { '=','=','&lt;','&lt;','&gt;','0','&gt;' },
        { '=','=','&lt;','&lt;','&gt;','0','&gt;' },
        { '&gt;','&gt;','=','=','&gt;','0','&gt;' },
        { '&gt;','&gt;','=','=','&gt;','0','&gt;' },
        { '&lt;','&lt;','&lt;','&lt;','&lt;','=','0' },
        { '0','0','0','0','0','0','0' },
        { '&lt;','&lt;','&lt;','&lt;','&lt;','0','=' },
    };

int getIndex(string ch){    //将运算符转换成相应的下标
	if(ch==&quot;+&quot;){
		return 0;
	}
	if(ch==&quot;-&quot;){
		return 1;
	}
	if(ch==&quot;*&quot;){
		return 2;
	}
	if(ch==&quot;/&quot;){
		return 3;
	}
	if(ch==&quot;(&quot;){
		return 4;
	}
	if(ch==&quot;)&quot;){
		return 5;
	}
	if(ch==&quot;#&quot;){
		return 6;
	}
}

bool isDegital(string str) {  //判断一个string是否为整数
    for (int i = 0;i &lt; str.size();i++) {
        if (str.at(i) == '-' &amp;&amp; str.size() &gt; 1)  // 有可能出现负数
            continue;
        if (str.at(i) &gt; '9' || str.at(i) &lt; '0')
            return false;
    }
    return true;
}


int to_int(string ch){   //将string转换为整数
	stringstream ss;
	int value;
	ss&lt;&lt;ch;
	ss&gt;&gt;value;
	return value;
}

stack&lt;string&gt; switchIt(string str){  //将传输过来的表达式转换为逆序

	stack&lt;string&gt; s1;
	stack&lt;string&gt; s2;
	stack&lt;string&gt; s3;
	s1.push(&quot;#&quot;);
    int counter = 0;

	for(int i=0;i&lt;str.length();i++){
		string ch(1,str[i]);
		
		if(isDegital(ch)){
			if(counter==1){
				string t=s2.top();
				s2.pop();
				int val1,val2,new_val;
				stringstream ss1,ss2,ss3;
				ss1&lt;&lt;t;
				ss1&gt;&gt;val1;
				ss2&lt;&lt;ch;
				ss2&gt;&gt;val2;
				new_val=val1*10+val2;
				string new_str;
				ss3&lt;&lt;new_val;
				new_str=ss3.str();
				s2.push(new_str);
			}
			else{
				s2.push(ch);
				counter++;
			}
		}
		else if(ch==&quot;(&quot;){
                counter=0;
			s1.push(ch);
		}
		else if(ch==&quot;)&quot;){
                counter=0;
			while(s1.top()!=&quot;(&quot;){
				s2.push(s1.top());
				s1.pop();
			}
			s1.pop();
		}
		else{
		    counter=0;
			int index1=getIndex(ch);
			int index2=getIndex(s1.top());
			char cmp=priority[index1][index2];
			if(cmp=='&gt;'){
				s1.push(ch);
			}
			else{
				while(cmp!='&gt;'){
					s2.push(s1.top());
					s1.pop();
					int index1=getIndex(ch);
					int index2=getIndex(s1.top());
					cmp=priority[index1][index2];
				}
				s1.push(ch);
			}
		}
	}

	while(!s1.empty()&amp;&amp;s1.top()!=&quot;#&quot;){
		s2.push(s1.top());
		s1.pop();
	}

	while(!s2.empty()){
		s3.push(s2.top());
		s2.pop();
	}

	return s3;

}

int main(){
	cout &lt;&lt; &quot;Please input an expression:&quot; &lt;&lt; endl;
	string str;
	cin&gt;&gt;str;
	stack&lt;string&gt; res=switchIt(str);
	stack&lt;int&gt; values;
//	while(!res.empty()){
//		cout&lt;&lt;res.top();
//		res.pop();
//	}
	while(!res.empty()){
		string ch=res.top();
		int counter=0;
		if(isDegital(ch)){
			int value=to_int(ch);
			values.push(value);
		}
		else if(ch==&quot;+&quot;){
			int val1=values.top();
			values.pop();
			int val2=values.top();
			values.pop();
			values.push(val1+val2);
			cout&lt;&lt;val2&lt;&lt;&quot;+&quot;&lt;&lt;val1&lt;&lt;&quot;=&quot;&lt;&lt;val1+val2&lt;&lt;endl;
		}
		else if(ch==&quot;-&quot;){
			int val1=values.top();
			values.pop();
			int val2=values.top();
			values.pop();
			values.push(val2-val1);
			cout&lt;&lt;val2&lt;&lt;&quot;-&quot;&lt;&lt;val1&lt;&lt;&quot;=&quot;&lt;&lt;val2-val1&lt;&lt;endl;
		}
		else if(ch==&quot;*&quot;){
			int val1=values.top();
			values.pop();
			int val2=values.top();
			values.pop();
			values.push(val1*val2);
			cout&lt;&lt;val2&lt;&lt;&quot;*&quot;&lt;&lt;val1&lt;&lt;&quot;=&quot;&lt;&lt;val2*val1&lt;&lt;endl;
		}
		else if(ch==&quot;/&quot;){
			int val1=values.top();
			values.pop();
			int val2=values.top();
			values.pop();
			if(val1==0){
			cout&lt;&lt;&quot;error:The divisor is 0.&quot;;
			exit(0);
			}
			values.push(val2/val1);
			cout&lt;&lt;val2&lt;&lt;&quot;/&quot;&lt;&lt;val1&lt;&lt;&quot;=&quot;&lt;&lt;val2/val1&lt;&lt;endl;
		}
		res.pop();
	}

	cout&lt;&lt;&quot;The result of the expression:&quot;&lt;&lt;values.top();

	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[近期杂谈]]></title>
        <id>https://zy-zzf2000.github.io//post/zatna01</id>
        <link href="https://zy-zzf2000.github.io//post/zatna01">
        </link>
        <updated>2019-10-08T15:16:27.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>算法第四版真是太难啃了，我决定先啃算法笔记。</li>
<li>我居然开始享受健身的过程。看到自己在向好的方向变化真的会让人上瘾。</li>
<li>无所事事的人最容易胡思乱想。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[cin和cout运行超时的问题]]></title>
        <id>https://zy-zzf2000.github.io//post/ioc</id>
        <link href="https://zy-zzf2000.github.io//post/ioc">
        </link>
        <updated>2019-10-07T15:00:06.000Z</updated>
        <content type="html"><![CDATA[<p>在代码中加入：</p>
<pre><code>std::ios::sync_with_stdio(false);
cin.tie(NULL);
</code></pre>
<p>可以使cin与cout的运行效率几乎与scanf和printf一样。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[c++ sort函数的基本应用]]></title>
        <id>https://zy-zzf2000.github.io//post/sort</id>
        <link href="https://zy-zzf2000.github.io//post/sort">
        </link>
        <updated>2019-10-07T14:02:18.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-sort函数的基本格式">1、sort函数的基本格式：</h1>
<p>sort（首元素地址，尾元素地址的下一个地址，cmp（非必填））</p>
<hr>
<h1 id="2-cmp函数">2、cmp函数</h1>
<p>cmp函数是一个自定义的比较函数，它返回一个bool值，用于返回两个类在sort函数中的大小关系。如：</p>
<pre><code class="language-c++">bool cmp(student a,student b){
	if(a.score!=b.score){
		return a.score&gt;b.score;
	}
	else{
		return a.id&lt;b.id;
	}
}
</code></pre>
<p>这段代码表示当学生成绩不一致时，按成绩从大到小排序，否则，按学号从小到大排序。</p>
<hr>
<h1 id="3-当排序有并列时应该怎么样做">3、当排序有并列时，应该怎么样做。</h1>
<p>让排序后的第一个元素排名为1，定义一个int 型变量r=1，遍历所有元素，当当前元素分数等于上一个元素时，当前元素排名也等于上一个元素，否则令元素排名为r。</p>
]]></content>
    </entry>
</feed>