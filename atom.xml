<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zy-zzf2000.github.io/</id>
    <title>小张的网站</title>
    <updated>2019-09-10T14:39:14.698Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zy-zzf2000.github.io/"/>
    <link rel="self" href="https://zy-zzf2000.github.io//atom.xml"/>
    <subtitle>莫道君行早，更有早行人</subtitle>
    <logo>https://zy-zzf2000.github.io//images/avatar.png</logo>
    <icon>https://zy-zzf2000.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, 小张的网站</rights>
    <entry>
        <title type="html"><![CDATA[Union Find 的Quick union实现]]></title>
        <id>https://zy-zzf2000.github.io//post/Quick union</id>
        <link href="https://zy-zzf2000.github.io//post/Quick union">
        </link>
        <updated>2019-09-10T11:25:49.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>继上次Quick find实现，为了解决每次连通两个结点都需要历遍整个数组的缺点，还有一种Quick union的实现。</p>
</blockquote>
<hr>
<h1 id="1quick-union实现的基本想法">（1）Quick union实现的基本想法</h1>
<p>与上次一样，Quick union算法所使用的基本数据结构还是整数数组，不同的是，这次需要两个整型数组，一个为id【N】，一个为size【N】。id【N】代表的是由结点组成的一片森林，其中，数组的元素主要用来存放索引的父节点，如果id【1】的值为0，则代表1结点的父节点是0结点，size【N】主要用来存放以索引为根结点的树的大小。如size【0】的值为5，则代表以0为根结点的树大小为5（即这颗树即一共有5个结点）。<br>
<img src="https://zy-zzf2000.github.io//post-images/1568115818472.png" alt=""></p>
<ul>
<li>Find方法：分别沿着id数组寻找根节点，查询两个根节点是否相同</li>
<li>union方法：分别沿着id数组寻找根节点，将其中一个根节点改为另一个根节点的子节点。<br>
不难发现，无论是find方法还是union方法，都需要寻找根节点，因此树的大小是影响该算法性能的一个重要因素，因此后面将对此进行优化。</li>
</ul>
<hr>
<h1 id="2实现代码">(2)实现代码</h1>
<pre><code class="language-java">public class QuickunionUF {
	private int[] id;	 //用来保存相应索引的父节点
	private int[] size;  //用来保存对应以相应索引为根节点的树的大小
	
	public QuickunionUF(int N) { //对各个结点进行初始化
		id=new int[N];
		for(int i=0;i&lt;N;i++) {
			id[i] =i;
		}
		size=new int[N];
		for(int i=0;i&lt;N;i++) {
			size[i]=1;
		}
	}
	
	public int root(int p) { //寻找根节点
		while(id[p]!=p) {
			id[p]=id[id[p]]; //这一行是为了减少树的高度，即让每个结点指向其祖父结点
			p=id[p];
		}
		return p;
	}
	
	public boolean Isconnect(int p,int q) {
		return root(p)==root(q);
	}
	
	public void union(int p,int q) { //使两个结点连通
		int rootp=root(p);
		int rootq=root(q);
		if(size[rootp]&lt;size[rootq]) { //根据p,q所在树的大小，尽量减小树的高度
			id[rootp]=rootq;
			size[rootq]=size[rootq]+size[rootp];
		}
		else {
			id[rootq]=rootp;
			size[rootp]+=size[rootq];
		}		
	}
	
	public static void main(String[] args) {
		QuickunionUF test=new QuickunionUF(10);
		test.union(1, 2);
		test.union(1, 7);
		test.union(3, 4);
		test.union(4, 5);
		test.union(0, 6);
		test.union(0, 8);
		test.union(6, 9);
		System.out.println(&quot;2 and 7&quot;+test.Isconnect(2, 7));
		System.out.println(&quot;3 and 5&quot;+test.Isconnect(3, 5));
		System.out.println(&quot;0 and 9&quot;+test.Isconnect(0, 9));
		System.out.println(&quot;0 and 7&quot;+test.Isconnect(0, 7));
	}
}
</code></pre>
<p>在上面的代码中，主要由两处进行了优化，第一处是root方法中，</p>
<pre><code class="language-java">id[p]=id[id[p]];
</code></pre>
<p>这一行的代码是让结点从指向父节点该为指向祖父结点，这样就有效减少了树的高度。事实上，我们可以将所有结点都改为指向根结点（也被成为树的完全展平），进一步减小树的高度，但在实际使用中，完全展平与上述代码效率相差无几，由于上述方法只需要一行代码即可实现，我们采用上述代码。</p>
<p>第二处优化是union方法中，</p>
<pre><code class="language-java">if(size[rootp]&lt;size[rootq]) { //根据p,q所在树的大小，尽量减小树的高度
			id[rootp]=rootq;
			size[rootq]=size[rootq]+size[rootp];
		}
		else {
			id[rootq]=rootp;
			size[rootp]+=size[rootq];
		}
</code></pre>
<p>在union方法中，我们根据树的大小进行不同的操作。可以发现，我们总是让大树<br>
的根节点成为小树根节点的父节点。这样做同样是为了减少树的高度。</p>
<hr>
<h1 id="3quick-union的优缺点">（3）Quick union的优缺点</h1>
<p>优点：Quick union的union的时间复杂度为O（lgN~N），假设由一颗共N个结点的树，若该树为满二叉树，那么最高层的树叶必须经过lgN次，才能找到根节点；如果该树为斜树，那么最高层的树叶必须经过N次，才能找到根节点。<br>
（由于对root函数进行了优化，事实上，Quick union的find函数的时间复杂度也相当低，因此这个算法基本上算是某种程度的“最佳算法”）。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Union Find 的Quick find实现]]></title>
        <id>https://zy-zzf2000.github.io//post/union-find-de-quick-find-shi-xian</id>
        <link href="https://zy-zzf2000.github.io//post/union-find-de-quick-find-shi-xian">
        </link>
        <updated>2019-09-09T15:19:45.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>Union FInd，在我个人的理解，就是点与点之间是否互相连通的问题。具体关于问题的描述，可以<a href="https://blog.csdn.net/guoziqing506/article/details/78752557">参考这里</a>动态连通性的前三段，或者Algorithm 4th的P136-1.5.1</p>
</blockquote>
<h1 id="1quick-find实现的基本想法">（1）Quick find实现的基本想法：</h1>
<p>通过一个整数数组来保存图中所有的点及它们之间的关系，更具体来说，两个点P与Q是连通的，当且仅当索引P与索引Q在数组中所对应的项是相同的。这样说可能有点难以理解，下面看一个例子：<br>
<img src="https://zy-zzf2000.github.io//post-images/1568043231866.png" alt=""><br>
图中的数组保存了10个点的关系，可以看到，{0，5，6}，{1，2，7}，{8，3，4，9}分别是三个连通分支，所以id【0】=id【5】=id【6】=0...</p>
<hr>
<h1 id="2实现代码">（2）实现代码：</h1>
<pre><code class="language-java">public class QuickFindUF {
	private int[] id;
	
	public QuickFindUF(int N) {//输入元素个数N，进行初始化
		id=new int[N];
		for(int i=0;i&lt;N;i++) {
			id[i]=i;
		}
	}
	
	public boolean Isconnected(int p,int q) { //如果两个索引对应的值相等，则说明pq相连
		return id[p]==id[q];
	}
	
	public void union(int p,int q) {//实现将pq相连的方法，在这里，我们让数组中所有值等于id【p】的索引的值都改为id【q】，因为一个元素如果与连通分支中的一个元素相连，那么它与该连通分支的其他元素也相连。
		int pid=id[p];
		int qid=id[q];
		for(int i=0;i&lt;id.length;i++) {
			if(id[i]==pid) {
				id[i]=qid;
			}
		}
	}
	
	public static void main(String[] args) {
		QuickFindUF demo=new QuickFindUF(10);
		demo.union(0, 1);
		demo.union(1, 2);
		demo.union(2, 3);
		demo.union(4, 5);
		demo.union(5, 6);
		demo.union(6, 7);
		demo.union(7, 8);
		System.out.println(&quot;0 and 3&quot;+demo.Isconnected(0, 3));
		System.out.println(&quot;4 and 8&quot;+demo.Isconnected(4, 8));
		System.out.println(&quot;0 and 9&quot;+demo.Isconnected(0, 9));
	}
}
</code></pre>
<hr>
<h1 id="3quick-find实现的优缺点">(3)Quick Find实现的优缺点：</h1>
<p>优点：查询两个点是否连接的效率非常高，仅需访问数组一次。<br>
缺点：连接两个点是效率极低，需要历遍整个数组，算法效率为N乘以某个常数</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java语言中如何使一个类可迭代]]></title>
        <id>https://zy-zzf2000.github.io//post/Iterable</id>
        <link href="https://zy-zzf2000.github.io//post/Iterable">
        </link>
        <updated>2019-09-08T02:14:17.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1在该类的声明中加入implements-iterable-item-实现iterable接口">（1）在该类的声明中加入implements Iterable&lt; Item &gt;(实现Iterable接口）</h1>
<p>其中，对应的接口（java.lang.Iterable)为：</p>
<pre><code class="language-java">public interface Iterable&lt;Item&gt;{
	Iterator&lt;Item&gt; iterator();
}
</code></pre>
<hr>
<h1 id="2在该类内定义一个嵌套类嵌套类需实现iterator接口">(2)在该类内定义一个嵌套类，嵌套类需实现Iterator接口。</h1>
<p>其中，对应的接口（java.util.Itearot)为：</p>
<pre><code class="language-java">public interface Iterator&lt;Item&gt;{
boolean hasNext();
Item next();
void remove();
}
</code></pre>
<hr>
<h1 id="3一个实现了可迭代的下压栈">(3)一个实现了可迭代的下压栈</h1>
<p>在这个例子中：</p>
<ul>
<li>栈顶的元素总是保存在a [ N-1 ]中（除非栈为空）</li>
<li>事实上，用链表实现栈更为简单，性能应该也更好</li>
</ul>
<pre><code class="language-java">import java.util.Iterator;

public class ResizingArrayStack&lt;Item&gt; implements Iterable&lt;Item&gt;{
	private Item[] a=(Item[]) new Object[1];  //a用于保存压入栈中的元素，初始大小为1
	private int N=0;//栈中元素数量
	
	public boolean isEmpty() {
		return N==0;
	}
	
	public int size() {
		return N;
	}
	
	private void resize(int num) {//将栈移动到一个大小为num的数组
		Item[] temp=(Item[]) new Object[num];//java语言不支持创建泛型数组，因此只能使用强制类型转换	
		for(int i=0;i&lt;N;i++) {
			temp[i]=a[i];
		}
		a=temp;
	}
	
	public void push(Item item) {//将元素压入栈中
		if(N==a.length) {
			resize(2*a.length);
		}
		a[N++]=item;
	}
	
	public Item pop() {//从栈顶弹出元素
		Item item=a[--N];
		a[N]=null;//覆盖a[N]的引用，让java垃圾收集器回收弹出元素所占的空间
		if(N&gt;0&amp;&amp;N==a.length/4) {//避免开辟的数组空间过大而造成浪费
			resize(a.length/2);
		}
		return item;
	}
	
	public Iterator&lt;Item&gt; iterator(){
		return new ReverseArrayIterator();
	}
	
	//这是一个逆向迭代数组的迭代子，因为栈总是后进先出
	private class ReverseArrayIterator implements Iterator&lt;Item&gt;{
		private int i=N;//在实现Iterator接口时，总需要先定义一个实例变量，用来记录当前结点，一把会把它初始化为需要开始迭代的地方
		
		public boolean hasNext() {
			return i&gt;0;
		}
		
		public Item next() {
			return a[--i];
		}
		
		public void remove() {
			//书上的说法是remove方法总为空，避免迭代时修改数据结构的操作，好吧...
		}	
	}	
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[栈的简单应用——双栈法实现算数表达式求值]]></title>
        <id>https://zy-zzf2000.github.io//post/SimpleStack</id>
        <link href="https://zy-zzf2000.github.io//post/SimpleStack">
        </link>
        <updated>2019-09-04T10:55:01.000Z</updated>
        <summary type="html"><![CDATA[<p>通过简单的机制处理由（）、+、-、* 所组成表达式的优先级运算</p>
]]></summary>
        <content type="html"><![CDATA[<p>通过简单的机制处理由（）、+、-、* 所组成表达式的优先级运算</p>
 <!-- more --> 
<hr>
<h1 id="1算法具体方法">（1）算法具体方法</h1>
<ol>
<li>将操作数压入操作数栈</li>
<li>将运算符压入运算符栈</li>
<li>忽略左括号</li>
<li>如果遇到右括号，弹出一个运算符，弹出所需数量的操作数，并将运算符和操作数的运算结果压入操作数栈</li>
<li>处理完算数表达式后，操作数栈最后只剩一个一个数字，该数字即为算数表达式的运算结果。</li>
</ol>
<hr>
<h1 id="2简单证明">（2）简单证明</h1>
<p>当遇到一个右括号时，算法弹出一个运算符和所需的操作数，并将结果压入操作数栈，这实际上相当于用该子表达式的结果代替了该表达式，如此循环往复，最后一个压入操作数栈的数字即为运算结果。</p>
<hr>
<h1 id="3实现代码">（3）实现代码</h1>
<pre><code class="language-java">import java.util.Scanner;
import java.util.Stack;

public class Calc {
	
	public static double evaluate(String str) {
		Stack&lt;Character&gt; ops=new Stack&lt;&gt;();
		Stack&lt;Double&gt; vals=new Stack&lt;&gt;();
		for(int i=0;i&lt;str.length();i++) {
			char s= str.charAt(i);
			if(s=='(')					;
			else if(s=='+')	 ops.push(s)；        //读取运算符
			else if(s=='-')		ops.push(s);
			else if(s=='*')		ops.push(s);
			else if(s=='/')		ops.push(s);
			else if(s==')') {      //如果为')'，弹出运算符和操作数，并将计算结果压入栈中
				char op=ops.pop();
				double val=vals.pop();        
				if(op=='+')		val+=vals.pop();
				else if(op=='-')		val-=vals.pop();
				else if(op=='*')		val*=vals.pop();
				else if(op=='/')		val/=vals.pop();
				vals.push(val);
			}    //既不是运算符，也不是括号，那么就将其压入操作数栈中
			else		vals.push(Double.parseDouble(String.valueOf(s)));
		}
		return vals.pop();
	}
	
	public static void main(String[] args) {
		Scanner in=new Scanner(System.in);
		System.out.println(&quot;请输入算数表达式：&quot;);
		String expr=in.next();
		double res=evaluate(expr);
		System.out.println(&quot;-------------------------------------&quot;);
		System.out.println(expr+&quot;=&quot;+res);
		in.close();
	}
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于]]></title>
        <id>https://zy-zzf2000.github.io//post/about</id>
        <link href="https://zy-zzf2000.github.io//post/about">
        </link>
        <updated>2019-08-31T11:09:48.000Z</updated>
        <content type="html"><![CDATA[<p>这个博客主要用来记录学习<em>Algorithm 4th</em>及<em>java web</em>的学习过程，有时也会用于分享一些生活的感受。</p>
]]></content>
    </entry>
</feed>