<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zy-zzf2000.github.io/</id>
    <title>小张的网站</title>
    <updated>2019-10-26T14:41:17.422Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zy-zzf2000.github.io/"/>
    <link rel="self" href="https://zy-zzf2000.github.io//atom.xml"/>
    <subtitle>莫道君行早，更有早行人</subtitle>
    <logo>https://zy-zzf2000.github.io//images/avatar.png</logo>
    <icon>https://zy-zzf2000.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, 小张的网站</rights>
    <entry>
        <title type="html"><![CDATA[KMP算法-从PMT角度理解]]></title>
        <id>https://zy-zzf2000.github.io//post/KMP</id>
        <link href="https://zy-zzf2000.github.io//post/KMP">
        </link>
        <updated>2019-10-19T14:43:45.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>在最近的课堂上，老师讲了KMP算法，但总感觉老师的推理过程有些不连贯，所以决定自己梳理一遍KMP算法</p>
</blockquote>
<hr>
<h1 id="1-next数组是什么">1、next数组是什么</h1>
<p>KMP算法的核心就是next数组。在KMP算法中，模式字符串的每一位均对应一个next值，即当主字符串与模式字符串在这一位发生失配时，模式字符串的指针不用回溯到0，只需回溯到next值即可。理解next数组是理解KMP算法的关键。</p>
<hr>
<h1 id="2-next数组的由来">2、next数组的由来</h1>
<p>在课本中，KMP算法是由BF算法改进而来的。但我个人认为这样并不好理解（其实是我当初看的时候没看懂，结果上课又没听懂）。在网上查阅之后，发现从PMT数组的角度似乎能更好的理解next数组。</p>
<p>PMT数组，即部分匹配表(Partial Match Table)，与next数组一样，对于模式字符串的每一位，它都有一个对应的值，如下图：<br>
<img src="https://zy-zzf2000.github.io//post-images/1572084892998.jpg" alt=""><br>
通俗的说，next数组里的值就是模式字符串当前位置子串中，前缀与后缀最大重复元素的长度。这样说也许还是难以理解，让我们用上图来举几个例子。<br>
可以看到，PMT【1】=0，这是因为对于字串“ab”，它的前缀只有‘a’，后缀只有‘b’，因此没有重复部分；PMT【2】=1，这是因为对于字串“aba”，它的前缀有“a”、“ab”，后缀有“ba”、“a”，其中最大重复元素位“a”，因此最大重复元素的长度=PMT值=1。以此类推...</p>
<p>PMT数组有什么用呢？PMT数组可以用来帮我们省去一些不必要的比较。如下图所示：<br>
<img src="https://zy-zzf2000.github.io//post-images/1572085486261.jpg" alt=""><br>
在图（a）中，主串与模式字符串即将发生失配。由PMT数组我们知道，对于模式字符串的子串“ababab”（即指针j前的字串），它的PMT值为4<br>
（PMT【j-1】），也就是说，它的前缀与后缀有4位是重复的。而主串与模式字符串失配前的每一位都是一样的，于是我们可以得出，主串的i指针之前的4位，相当于“ababab”的后缀，而模式字符串的前四位，相当于“ababab”的前缀，他们也是相等的。既然模式字符串的前四位已经相等了，那么我们在下一次进行比较的时候，就没有必要再对它们进行比较了，如图（b）所示，我们保持i指针不变，直接将j指针移动到第五位，直接从模式字符串的第五位开始比较。</p>
<p>从上面我们可以看出，如果再比较时，考虑PMT数组，那么每当发生失配时，我们的j指针就不必回溯到0，只需要回溯到j指针前一位，即PMT【j-1】所指示的位置。为了编程方便，我们将PMT数组整体后移一位，这样就得到了next数组。原来next数组只是一个提供便利的“衍生物”。如下图所示：<br>
<img src="https://zy-zzf2000.github.io//post-images/1572086367096.jpg" alt=""><br>
在上图中可以发现next【0】被设置为了-1，这是为了便于编程，使我们知道主串在第一位便发生了失配，这时候，i指针就要向后移动一位。</p>
<hr>
<h1 id="3-代码">3、代码</h1>
<p>既然明白了next数组的由来，我个人认为实现它也就不困难了。</p>
<pre><code class="language-c++">int KMP(char* t,char* p){
	int i=0,j=0;;
	while(i&lt;strlen(t)&amp;&amp;j&lt;strlen(p)){
		if(j==-1){		//如果j=-1，说明主串第一个字符就与模式字符串失配 
			i++;		//主串指针下移一位 
			j=0;		//模式字符串指针回溯到0 
		}
		else if(t[i]==p[j]){	//如果当前位相等，则继续比较下一位 
			i++;
			j++;
		}
		else{			//发生失配 
			j=next[j];	//模式字符串回溯到next[j]处 
		}
	}
} 
</code></pre>
<p>当然，如何实现next数组甚至比KMP算法更关键<br>
这里我直接引用知乎上的说法：</p>
<blockquote>
<p>其实，求next数组的过程完全可以看成字符串匹配的过程，即以模式字符串为主字符串，以模式字符串的前缀为目标字符串，一旦字符串匹配成功，那么当前的next值就是匹配成功的字符串的长度。<br>
具体来说，就是从模式字符串的第一位(注意，不包括第0位)开始对自身进行匹配运算。 在任一位置，能匹配的最长长度就是当前位置的next值。</p>
</blockquote>
<p>下面是几张图片：<br>
<img src="https://zy-zzf2000.github.io//post-images/1572100503477.jpg" alt=""><br>
<img src="https://zy-zzf2000.github.io//post-images/1572100507615.jpg" alt=""><br>
<img src="https://zy-zzf2000.github.io//post-images/1572100511040.jpg" alt=""><br>
<img src="https://zy-zzf2000.github.io//post-images/1572100514912.jpg" alt=""><br>
<img src="https://zy-zzf2000.github.io//post-images/1572100518437.jpg" alt=""><br>
值得注意的是，计算next数组时，要从第一位开始，即第0位不参与，且联系前面的PMT数组我们知道，next数组是PMT数组整体后移一位得到的，因此在第1位得到的匹配长度实际上应该是next【2】的值，以此类推...</p>
<pre><code class="language-c++">void getNext(char *p,int *next){
	next[0]=-1;  //next[0]被约定为-1
	int i=0,j=-1;
	while(i &lt; strlen(p)) {
		if (j == -1 || p[i] == p[j]){
			++i;
			++j;
			next[i] = j;
		}
		else{
			j = next[j];
		}
	}
} 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[逆波兰算法实现简单优先计算器]]></title>
        <id>https://zy-zzf2000.github.io//post/ni-bo-lan-suan-fa-shi-xian-jian-dan-you-xian-ji-suan-ji</id>
        <link href="https://zy-zzf2000.github.io//post/ni-bo-lan-suan-fa-shi-xian-jian-dan-you-xian-ji-suan-ji">
        </link>
        <updated>2019-10-17T14:43:18.000Z</updated>
        <content type="html"><![CDATA[<p>待续..</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[近期杂谈]]></title>
        <id>https://zy-zzf2000.github.io//post/zatna01</id>
        <link href="https://zy-zzf2000.github.io//post/zatna01">
        </link>
        <updated>2019-10-08T15:16:27.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>算法第四版真是太难啃了，我决定先啃算法笔记。</li>
<li>我居然开始享受健身的过程。看到自己在向好的方向变化真的会让人上瘾。</li>
<li>果然忙起来就没时间想这想那的了。无所事事的人最容易胡思乱想。</li>
<li>学校奖学金啥时候发啊，没蛋白粉增肌太慢了。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[cin和cout运行超时的问题]]></title>
        <id>https://zy-zzf2000.github.io//post/ioc</id>
        <link href="https://zy-zzf2000.github.io//post/ioc">
        </link>
        <updated>2019-10-07T15:00:06.000Z</updated>
        <content type="html"><![CDATA[<p>在代码中加入：</p>
<pre><code>std::ios::sync_with_stdio(false);
cin.tie(NULL);
</code></pre>
<p>可以使cin与cout的运行效率几乎与scanf和printf一样。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[c++ sort函数的基本应用]]></title>
        <id>https://zy-zzf2000.github.io//post/sort</id>
        <link href="https://zy-zzf2000.github.io//post/sort">
        </link>
        <updated>2019-10-07T14:02:18.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-sort函数的基本格式">1、sort函数的基本格式：</h1>
<p>sort（首元素地址，尾元素地址的下一个地址，cmp（非必填））</p>
<hr>
<h1 id="2-cmp函数">2、cmp函数</h1>
<p>cmp函数是一个自定义的比较函数，它返回一个bool值，用于返回两个类在sort函数中的大小关系。如：</p>
<pre><code class="language-c++">bool cmp(student a,student b){
	if(a.score!=b.score){
		return a.score&gt;b.score;
	}
	else{
		return a.id&lt;b.id;
	}
}
</code></pre>
<p>这段代码表示当学生成绩不一致时，按成绩从大到小排序，否则，按学号从小到大排序。</p>
<hr>
<h1 id="3-当排序有并列时应该怎么样做">3、当排序有并列时，应该怎么样做。</h1>
<p>让排序后的第一个元素排名为1，定义一个int 型变量r=1，遍历所有元素，当当前元素分数等于上一个元素时，当前元素排名也等于上一个元素，否则令元素排名为r。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[双指针法]]></title>
        <id>https://zy-zzf2000.github.io//post/doubleptr</id>
        <link href="https://zy-zzf2000.github.io//post/doubleptr">
        </link>
        <updated>2019-10-01T11:04:12.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>通过两道例题来体会双指针法的使用。</p>
</blockquote>
<hr>
<h1 id="1">1、</h1>
<blockquote>
<p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
</blockquote>
<p>数组完成排序后，我们可以放置两个指针 i 和 j，其中i是慢指针，而j是快指针。只要 nums[i]=nums[j]nums[i] = nums[j]nums[i]=nums[j]，我们就增加j以跳过重复项。<br>
当我们遇到 nums[j]≠nums[i]nums[j]时，跳过重复项的运行已经结束，因此我们必须把它（nums[j]）的值复制到 nums[i+1]上。然后递增i，接着我们将再次重复相同的过程，直到j到达数组的末尾为止。</p>
<pre><code class="language-java">public int removeDuplicates(int[] nums) {
    if (nums.length == 0) return 0;
    int i = 0;
    for (int j = 1; j &lt; nums.length; j++) {
        if (nums[j] != nums[i]) {
            i++;
            nums[i] = nums[j];
        }
    }
    return i + 1;
}
</code></pre>
<hr>
<h1 id="2">2、</h1>
<blockquote>
<p>给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。<br>
不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。<br>
元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<p>同上，我们可以保留两个指针i和j，其中i时慢指针，j是快指针。当 nums[j] 与给定的值相等时，递增j以跳过该元素。只要 nums[j]≠val，我们就复制 nums[j] 到 nums[i] 并同时递增两个索引。重复这一过程，直到j到达数组的末尾，该数组的新长度为i。</p>
<pre><code class="language-java">public int removeElement(int[] nums, int val) {
    int i = 0;
    for (int j = 0; j &lt; nums.length; j++) {
        if (nums[j] != val) {
            nums[i] = nums[j];
            i++;
        }
    }
    return i;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[初级排序算法——希尔排序]]></title>
        <id>https://zy-zzf2000.github.io//post/chu-ji-pai-xu-suan-fa-xi-er-pai-xu</id>
        <link href="https://zy-zzf2000.github.io//post/chu-ji-pai-xu-suan-fa-xi-er-pai-xu">
        </link>
        <updated>2019-09-24T07:47:20.000Z</updated>
        <content type="html"><![CDATA[<p>1</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[小波]]></title>
        <id>https://zy-zzf2000.github.io//post/0305</id>
        <link href="https://zy-zzf2000.github.io//post/0305">
        </link>
        <updated>2019-09-20T10:48:18.000Z</updated>
        <content type="html"><![CDATA[<p>后来我才知道，生活就是个缓慢受槌的过程，人一天天老下去，奢望也一天天消失，最后变得像挨了槌的牛一样。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一个基于动态调整大小数组的队列（FIFO）实现]]></title>
        <id>https://zy-zzf2000.github.io//post/ArrayQueue</id>
        <link href="https://zy-zzf2000.github.io//post/ArrayQueue">
        </link>
        <updated>2019-09-18T10:58:07.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>在java中，队列的实现由两种基本方式，一种是基于数组的实现方式，另一种是基于链表的实现方式。本文介绍基于数组的一种实现方式。</p>
</blockquote>
<pre><code class="language-java">package zy;

public class Myqueue&lt;Item&gt; {
	private Item[] a=(Item[]) new Object[2];
	private int N=0,head=0,tail=0;
	
	public Myqueue() {
	}
	
	public void resize(int newsize) {  //给数组重新分配空间
		Item[] array=(Item[]) new Object[newsize];
		for(int i=0;i&lt;N;i++) {
			array[i]=a[head+i];
		}
		a=array;         //每次重新分配空间都要重置头索引和尾索引
		head=0;
		N-=head;
		tail=N-1+head;
	}
	
	public boolean isEmpty() {  
		return N==0;
	}
	
	public void enqueue(Item item) {  //入队操作
		if(isEmpty()) {
			a[tail]=item;
			N++;
		}
		else {	
			if(N==a.length) {
			resize(a.length*2);
			}
			int loca =tail+1;
			a[loca]=item;
			N++;
			tail++;
	    }		
	}
	
	public Item dequeue() {  //出队操作
		if(N==a.length/4) {
			resize(a.length/2);
		}
		Item item=a[head];
		a[head]=null;
		head++;
		N--;
		return item;
	}
	
	public static void main(String[] args) {
		Myqueue&lt;String&gt; queue=new Myqueue&lt;String&gt;();
		queue.enqueue(&quot;H&quot;);
		queue.enqueue(&quot;e&quot;);
		queue.enqueue(&quot;l&quot;);
		queue.enqueue(&quot;l&quot;);
		queue.enqueue(&quot;o&quot;);
		queue.enqueue(&quot;,&quot;);
		queue.enqueue(&quot;W&quot;);
		queue.enqueue(&quot;o&quot;);
		queue.enqueue(&quot;r&quot;);
		queue.enqueue(&quot;l&quot;);
		queue.enqueue(&quot;d&quot;);
		queue.enqueue(&quot;!&quot;);
		for(int j=0;j&lt;12;j++) {
			System.out.print(queue.dequeue());
		}
	}		
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[浅谈Java中main函数的args参数]]></title>
        <id>https://zy-zzf2000.github.io//post/args</id>
        <link href="https://zy-zzf2000.github.io//post/args">
        </link>
        <updated>2019-09-18T10:56:52.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p><a href="https://jingyan.baidu.com/article/86f4a73e63862a37d6526909.html">参考链接</a></p>
</blockquote>
<p>在java中，main函数都有一个String【】类型的args参数，那么这个参数有什么作用呢？</p>
<hr>
<h1 id="1-通过查阅相关资料我发现agrs参数是用来从命令行接受用户参数的">1、通过查阅相关资料，我发现，agrs参数是用来从命令行接受用户参数的。</h1>
<p>让我们新建一个Test类，看看args参数的具体使用过程：</p>
<pre><code class="language-java">public class Test {
	public static void main(String[] args) {
		for(String arg:args) {
			System.out.println(arg);
		}
	}
}
</code></pre>
<p>让我们的cmd里运行这个java程序：<br>
<img src="https://zy-zzf2000.github.io//post-images/1568992362093.png" alt=""><br>
可以看到，输出为空。也就是说在默认情况下，args参数为空。</p>
<p>让我们为其增加一下参数：<br>
<img src="https://zy-zzf2000.github.io//post-images/1568992494857.png" alt=""><br>
可以看到，输入为This is a Test，输出为This\n is\n a\n Test\n,也就是说，args是以“ ”切割输入为若干个字符串，储存在args数组中。</p>
<h1 id="2-在eclipse中使用args参数">2、在Eclipse中使用args参数</h1>
<p>在eclipse中，如果我们想要使用args数组，又该如何操作呢？</p>
<ol>
<li>鼠标右键-&gt;run as-&gt;Run Configurations</li>
<li>在弹出的窗口中，选中Arguments菜单，在Progam arguments中输出参数，同样以“ ”为分割符。</li>
</ol>
]]></content>
    </entry>
</feed>