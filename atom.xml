<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zy-zzf2000.github.io/</id>
    <title>小张的网站</title>
    <updated>2019-10-09T12:55:12.369Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zy-zzf2000.github.io/"/>
    <link rel="self" href="https://zy-zzf2000.github.io//atom.xml"/>
    <subtitle>莫道君行早，更有早行人</subtitle>
    <logo>https://zy-zzf2000.github.io//images/avatar.png</logo>
    <icon>https://zy-zzf2000.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, 小张的网站</rights>
    <entry>
        <title type="html"><![CDATA[近期杂谈]]></title>
        <id>https://zy-zzf2000.github.io//post/zatna01</id>
        <link href="https://zy-zzf2000.github.io//post/zatna01">
        </link>
        <updated>2019-10-08T15:16:27.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>算法第四版真是太难啃了，我决定先啃算法笔记。</li>
<li>我居然开始享受健身的过程。看到自己在向好的方向变化真的会让人上瘾。</li>
<li>果然忙起来就没时间想这想那的了。无所事事的人最容易胡思乱想。</li>
<li>学校奖学金啥时候发啊，没蛋白粉增肌太慢了。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[cin和cout运行超时的问题]]></title>
        <id>https://zy-zzf2000.github.io//post/ioc</id>
        <link href="https://zy-zzf2000.github.io//post/ioc">
        </link>
        <updated>2019-10-07T15:00:06.000Z</updated>
        <content type="html"><![CDATA[<p>在代码中加入：</p>
<pre><code>std::ios::sync_with_stdio(false);
cin.tie(NULL);
</code></pre>
<p>可以使cin与cout的运行效率几乎与scanf和printf一样。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[c++ sort函数的基本应用]]></title>
        <id>https://zy-zzf2000.github.io//post/sort</id>
        <link href="https://zy-zzf2000.github.io//post/sort">
        </link>
        <updated>2019-10-07T14:02:18.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-sort函数的基本格式">1、sort函数的基本格式：</h1>
<p>sort（首元素地址，尾元素地址的下一个地址，cmp（非必填））</p>
<hr>
<h1 id="2-cmp函数">2、cmp函数</h1>
<p>cmp函数是一个自定义的比较函数，它返回一个bool值，用于返回两个类在sort函数中的大小关系。如：</p>
<pre><code class="language-c++">bool cmp(student a,student b){
	if(a.score!=b.score){
		return a.score&gt;b.score;
	}
	else{
		return a.id&lt;b.id;
	}
}
</code></pre>
<p>这段代码表示当学生成绩不一致时，按成绩从大到小排序，否则，按学号从小到大排序。</p>
<hr>
<h1 id="3-当排序有并列时应该怎么样做">3、当排序有并列时，应该怎么样做。</h1>
<p>让排序后的第一个元素排名为1，定义一个int 型变量r=1，遍历所有元素，当当前元素分数等于上一个元素时，当前元素排名也等于上一个元素，否则令元素排名为r。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[双指针法]]></title>
        <id>https://zy-zzf2000.github.io//post/doubleptr</id>
        <link href="https://zy-zzf2000.github.io//post/doubleptr">
        </link>
        <updated>2019-10-01T11:04:12.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>通过两道例题来体会双指针法的使用。</p>
</blockquote>
<hr>
<h1 id="1">1、</h1>
<blockquote>
<p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
</blockquote>
<p>数组完成排序后，我们可以放置两个指针 i 和 j，其中i是慢指针，而j是快指针。只要 nums[i]=nums[j]nums[i] = nums[j]nums[i]=nums[j]，我们就增加j以跳过重复项。<br>
当我们遇到 nums[j]≠nums[i]nums[j]时，跳过重复项的运行已经结束，因此我们必须把它（nums[j]）的值复制到 nums[i+1]上。然后递增i，接着我们将再次重复相同的过程，直到j到达数组的末尾为止。</p>
<pre><code class="language-java">public int removeDuplicates(int[] nums) {
    if (nums.length == 0) return 0;
    int i = 0;
    for (int j = 1; j &lt; nums.length; j++) {
        if (nums[j] != nums[i]) {
            i++;
            nums[i] = nums[j];
        }
    }
    return i + 1;
}
</code></pre>
<hr>
<h1 id="2">2、</h1>
<blockquote>
<p>给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。<br>
不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。<br>
元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<p>同上，我们可以保留两个指针i和j，其中i时慢指针，j是快指针。当 nums[j] 与给定的值相等时，递增j以跳过该元素。只要 nums[j]≠val，我们就复制 nums[j] 到 nums[i] 并同时递增两个索引。重复这一过程，直到j到达数组的末尾，该数组的新长度为i。</p>
<pre><code class="language-java">public int removeElement(int[] nums, int val) {
    int i = 0;
    for (int j = 0; j &lt; nums.length; j++) {
        if (nums[j] != val) {
            nums[i] = nums[j];
            i++;
        }
    }
    return i;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[初级排序算法——希尔排序]]></title>
        <id>https://zy-zzf2000.github.io//post/chu-ji-pai-xu-suan-fa-xi-er-pai-xu</id>
        <link href="https://zy-zzf2000.github.io//post/chu-ji-pai-xu-suan-fa-xi-er-pai-xu">
        </link>
        <updated>2019-09-24T07:47:20.000Z</updated>
        <content type="html"><![CDATA[<p>1</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[小波]]></title>
        <id>https://zy-zzf2000.github.io//post/0305</id>
        <link href="https://zy-zzf2000.github.io//post/0305">
        </link>
        <updated>2019-09-20T10:48:18.000Z</updated>
        <content type="html"><![CDATA[<p>后来我才知道，生活就是个缓慢受槌的过程，人一天天老下去，奢望也一天天消失，最后变得像挨了槌的牛一样。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一个基于动态调整大小数组的队列（FIFO）实现]]></title>
        <id>https://zy-zzf2000.github.io//post/ArrayQueue</id>
        <link href="https://zy-zzf2000.github.io//post/ArrayQueue">
        </link>
        <updated>2019-09-18T10:58:07.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>在java中，队列的实现由两种基本方式，一种是基于数组的实现方式，另一种是基于链表的实现方式。本文介绍基于数组的一种实现方式。</p>
</blockquote>
<pre><code class="language-java">package zy;

public class Myqueue&lt;Item&gt; {
	private Item[] a=(Item[]) new Object[2];
	private int N=0,head=0,tail=0;
	
	public Myqueue() {
	}
	
	public void resize(int newsize) {  //给数组重新分配空间
		Item[] array=(Item[]) new Object[newsize];
		for(int i=0;i&lt;N;i++) {
			array[i]=a[head+i];
		}
		a=array;         //每次重新分配空间都要重置头索引和尾索引
		head=0;
		N-=head;
		tail=N-1+head;
	}
	
	public boolean isEmpty() {  
		return N==0;
	}
	
	public void enqueue(Item item) {  //入队操作
		if(isEmpty()) {
			a[tail]=item;
			N++;
		}
		else {	
			if(N==a.length) {
			resize(a.length*2);
			}
			int loca =tail+1;
			a[loca]=item;
			N++;
			tail++;
	    }		
	}
	
	public Item dequeue() {  //出队操作
		if(N==a.length/4) {
			resize(a.length/2);
		}
		Item item=a[head];
		a[head]=null;
		head++;
		N--;
		return item;
	}
	
	public static void main(String[] args) {
		Myqueue&lt;String&gt; queue=new Myqueue&lt;String&gt;();
		queue.enqueue(&quot;H&quot;);
		queue.enqueue(&quot;e&quot;);
		queue.enqueue(&quot;l&quot;);
		queue.enqueue(&quot;l&quot;);
		queue.enqueue(&quot;o&quot;);
		queue.enqueue(&quot;,&quot;);
		queue.enqueue(&quot;W&quot;);
		queue.enqueue(&quot;o&quot;);
		queue.enqueue(&quot;r&quot;);
		queue.enqueue(&quot;l&quot;);
		queue.enqueue(&quot;d&quot;);
		queue.enqueue(&quot;!&quot;);
		for(int j=0;j&lt;12;j++) {
			System.out.print(queue.dequeue());
		}
	}		
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[浅谈Java中main函数的args参数]]></title>
        <id>https://zy-zzf2000.github.io//post/args</id>
        <link href="https://zy-zzf2000.github.io//post/args">
        </link>
        <updated>2019-09-18T10:56:52.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p><a href="https://jingyan.baidu.com/article/86f4a73e63862a37d6526909.html">参考链接</a></p>
</blockquote>
<p>在java中，main函数都有一个String【】类型的args参数，那么这个参数有什么作用呢？</p>
<hr>
<h1 id="1-通过查阅相关资料我发现agrs参数是用来从命令行接受用户参数的">1、通过查阅相关资料，我发现，agrs参数是用来从命令行接受用户参数的。</h1>
<p>让我们新建一个Test类，看看args参数的具体使用过程：</p>
<pre><code class="language-java">public class Test {
	public static void main(String[] args) {
		for(String arg:args) {
			System.out.println(arg);
		}
	}
}
</code></pre>
<p>让我们的cmd里运行这个java程序：<br>
<img src="https://zy-zzf2000.github.io//post-images/1568992362093.png" alt=""><br>
可以看到，输出为空。也就是说在默认情况下，args参数为空。</p>
<p>让我们为其增加一下参数：<br>
<img src="https://zy-zzf2000.github.io//post-images/1568992494857.png" alt=""><br>
可以看到，输入为This is a Test，输出为This\n is\n a\n Test\n,也就是说，args是以“ ”切割输入为若干个字符串，储存在args数组中。</p>
<h1 id="2-在eclipse中使用args参数">2、在Eclipse中使用args参数</h1>
<p>在eclipse中，如果我们想要使用args数组，又该如何操作呢？</p>
<ol>
<li>鼠标右键-&gt;run as-&gt;Run Configurations</li>
<li>在弹出的窗口中，选中Arguments菜单，在Progam arguments中输出参数，同样以“ ”为分割符。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[山民]]></title>
        <id>https://zy-zzf2000.github.io//post/Shanmin</id>
        <link href="https://zy-zzf2000.github.io//post/Shanmin">
        </link>
        <updated>2019-09-14T07:01:21.000Z</updated>
        <content type="html"><![CDATA[<hr>
<p>小时候，他问父亲</p>
<p>“山那边是什么？”<br>
父亲说：“是山”<br>
“那边的那边呢？”<br>
“山，还是山”<br>
他不作声了，看着远处<br>
山第一次使他这样疲倦</p>
<p>他想，这辈子是走不出这里的群山了<br>
海是有的，但十分遥远<br>
他只能活几十年<br>
所以没有等他走到那里<br>
就已死在半路上了<br>
死在山中</p>
<p>他觉得应该带着老婆一起上路<br>
老婆会给他生个儿子<br>
到他死的时候<br>
儿子就长大了<br>
儿子也会有老婆<br>
儿子也会有儿子<br>
儿子的儿子也还会有儿子<br>
他不再想了<br>
儿子也使他很疲倦</p>
<p>他只是遗憾<br>
他的祖先没有像他一样想过<br>
不然，见到大海的该是他了</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Union Find 的Quick union实现]]></title>
        <id>https://zy-zzf2000.github.io//post/Quick union</id>
        <link href="https://zy-zzf2000.github.io//post/Quick union">
        </link>
        <updated>2019-09-10T11:25:49.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>继上次Quick find实现，为了解决每次连通两个结点都需要历遍整个数组的缺点，还有一种Quick union的实现。</p>
</blockquote>
<hr>
<h1 id="1quick-union实现的基本想法">（1）Quick union实现的基本想法</h1>
<p>与上次一样，Quick union算法所使用的基本数据结构还是整数数组，不同的是，这次需要两个整型数组，一个为id【N】，一个为size【N】。id【N】代表的是由结点组成的一片森林，其中，数组的元素主要用来存放索引的父节点，如果id【1】的值为0，则代表1结点的父节点是0结点，size【N】主要用来存放以索引为根结点的树的大小。如size【0】的值为5，则代表以0为根结点的树大小为5（即这颗树即一共有5个结点）。<br>
<img src="https://zy-zzf2000.github.io//post-images/1568115818472.png" alt=""></p>
<ul>
<li>Find方法：分别沿着id数组寻找根节点，查询两个根节点是否相同</li>
<li>union方法：分别沿着id数组寻找根节点，将其中一个根节点改为另一个根节点的子节点。<br>
不难发现，无论是find方法还是union方法，都需要寻找根节点，因此树的大小是影响该算法性能的一个重要因素，因此后面将对此进行优化。</li>
</ul>
<hr>
<h1 id="2实现代码">(2)实现代码</h1>
<pre><code class="language-java">public class QuickunionUF {
	private int[] id;	 //用来保存相应索引的父节点
	private int[] size;  //用来保存对应以相应索引为根节点的树的大小
	
	public QuickunionUF(int N) { //对各个结点进行初始化
		id=new int[N];
		for(int i=0;i&lt;N;i++) {
			id[i] =i;
		}
		size=new int[N];
		for(int i=0;i&lt;N;i++) {
			size[i]=1;
		}
	}
	
	public int root(int p) { //寻找根节点
		while(id[p]!=p) {
			id[p]=id[id[p]]; //这一行是为了减少树的高度，即让每个结点指向其祖父结点
			p=id[p];
		}
		return p;
	}
	
	public boolean Isconnect(int p,int q) {
		return root(p)==root(q);
	}
	
	public void union(int p,int q) { //使两个结点连通
		int rootp=root(p);
		int rootq=root(q);
		if(size[rootp]&lt;size[rootq]) { //根据p,q所在树的大小，尽量减小树的高度
			id[rootp]=rootq;
			size[rootq]=size[rootq]+size[rootp];
		}
		else {
			id[rootq]=rootp;
			size[rootp]+=size[rootq];
		}		
	}
	
	public static void main(String[] args) {
		QuickunionUF test=new QuickunionUF(10);
		test.union(1, 2);
		test.union(1, 7);
		test.union(3, 4);
		test.union(4, 5);
		test.union(0, 6);
		test.union(0, 8);
		test.union(6, 9);
		System.out.println(&quot;2 and 7&quot;+test.Isconnect(2, 7));
		System.out.println(&quot;3 and 5&quot;+test.Isconnect(3, 5));
		System.out.println(&quot;0 and 9&quot;+test.Isconnect(0, 9));
		System.out.println(&quot;0 and 7&quot;+test.Isconnect(0, 7));
	}
}
</code></pre>
<p>在上面的代码中，主要由两处进行了优化，第一处是root方法中，</p>
<pre><code class="language-java">id[p]=id[id[p]];
</code></pre>
<p>这一行的代码是让结点从指向父节点该为指向祖父结点，这样就有效减少了树的高度。事实上，我们可以将所有结点都改为指向根结点（也被成为树的完全展平），进一步减小树的高度，但在实际使用中，完全展平与上述代码效率相差无几，由于上述方法只需要一行代码即可实现，我们采用上述代码。</p>
<p>第二处优化是union方法中，</p>
<pre><code class="language-java">if(size[rootp]&lt;size[rootq]) { //根据p,q所在树的大小，尽量减小树的高度
			id[rootp]=rootq;
			size[rootq]=size[rootq]+size[rootp];
		}
		else {
			id[rootq]=rootp;
			size[rootp]+=size[rootq];
		}
</code></pre>
<p>在union方法中，我们根据树的大小进行不同的操作。可以发现，我们总是让大树<br>
的根节点成为小树根节点的父节点。这样做同样是为了减少树的高度。</p>
<p>事实上，我们可以证明，在不考虑优化一（仅有优化二）的前提下，若共有k个结点，则树的高度至多为lgk。下面是一个证明：</p>
<ol>
<li>初始条件下，当k=1时，树高为0.</li>
<li>若k！=1，假设当前需要归并的树大小为i时，性质成立，即树高为lgi。因为只有与大小不小于自己的树归并，树高才会发生变化，因此我们设i&lt;=j且i+j=k（最坏情况）。这时，树高为lgi+1=lg（i+i）&lt;=lg（i+k）=lgk，注意，lg以2为底。</li>
</ol>
<hr>
<h1 id="3quick-union的优缺点">（3）Quick union的优缺点</h1>
<p>优点：仅仅只有优化二的Quick union的union方法与find方法的的时间复杂度均为O（lgN），而加上优化一之后，find方法与union方法的时间复杂度非常接近于O（1）。<br>
缺点：暂无。</p>
]]></content>
    </entry>
</feed>